/**
 * ：软件实体应该对扩展开放，对修改关闭，其
 * 含义是说一个软件实体应该通过扩展来实现变化，而不是通过修改已有的代码来实现变化。
 * 软件实体包括以下几个部分：<br/>
 * <ol>
 *     <li>项目或软件产品中按照一定的逻辑规则划分的模块。</li>
 *     <li>抽象和类。</li>
 *     <li>方法。</li>
 * </ol>
 * <br/>
 * 可以把变化归纳为以下三种类型：
 * <ol>
 *     <li>逻辑变化
 * 只变化一个逻辑，而不涉及其他模块，比如原有的一个算法是a*b+c，现在需要修改为 a*b*c，可以通过修改原有类中的方法的方式来完成，前提条件是所有依赖或关联类都按照
 * 相同的逻辑处理。</li>
 * <li>子模块变化
 * 一个模块变化，会对其他的模块产生影响，特别是一个低层次的模块变化必然引起高层
 * 模块的变化，因此在通过扩展完成变化时，高层次的模块修改是必然的，刚刚的书籍打折处
 * 理就是类似的处理模块，该部分的变化甚至会引起界面的变化。</li>
 * <li>可见视图变化可见视图是提供给客户使用的界面，如JSP程序、Swing界面等，该部分的变化一般会引
 * 起连锁反应（特别是在国内做项目，做欧美的外包项目一般不会影响太大）。如果仅仅是界
 * 面上按钮、文字的重新排布倒是简单，最司空见惯的是业务耦合变化，什么意思呢？一个展 示数据的列表，按照原有的需求是6列，突然有一天要增加1列，而且这一列要跨N张表，处 理M个逻辑才能展现出来，这样的变化是比较恐怖的，但还是可以通过扩展来完成变化，这
 * 就要看我们原有的设计是否灵活。</li>
 * </ol>
 * 开闭原则的作用
 * <ol>
 *     <li> 开闭原则对测试的影响</li>
 *     <li>开闭原则可以提高复用性</li>
 *     <li>开闭原则可以提高可维护性</li>
 *     <li>面向对象开发的要求</li>
 * </ol>
 * 应用方法
 * <ol>
 *     <li>抽象约束</li>
 *     <li>元数据（metadata）控制模块行为</li>
 *     <li> 制定项目章程</li>
 *     <li>封装变化</li>
 * </ol>
 * @author MayZhou
 */
package principle.ocp;