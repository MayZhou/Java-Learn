/**
 * 观察者模式
 *
 * 被观察者和观察者是多对多的关系
 *
 * 观察者模式（Observer Pattern）也叫做发布订阅模式（Publish/subscribe）,它是一个在项
 * 目中经常使用的模式，其定义如下：
 * Define a one-to-many dependency between objects so that when one object changes state,all its dependents are notified and updated automatically.（定义对象间一种一对多的依赖关系，使得每
 * 当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。）
 *
 *  观察者模式的优点
 * ● 观察者和被观察者之间是抽象耦合
 * 如此设计，则不管是增加观察者还是被观察者都非常容易扩展，而且在Java中都已经实
 * 现的抽象层级的定义，在系统扩展方面更是得心应手。
 * ● 建立一套触发机制
 * 根据单一职责原则，每个类的职责是单一的，那么怎么把各个单一的职责串联成真实世
 * 界的复杂的逻辑关系呢？比如，我们去打猎，打死了一只母鹿，母鹿有三个幼崽，因失去了
 * 母鹿而饿死，尸体又被两只秃鹰争抢，因分配不均，秃鹰开始斗殴，然后羸弱的秃鹰死掉， 生存下来的秃鹰，则因此扩大了地盘……这就是一个触发机制，形成了一个触发链。观察者
 * 模式可以完美地实现这里的链条形式。
 *
 * 观察者模式需要考虑一下开发效率和运行效率问题，一个被观察者，多个观察者，开发 和调试就会比较复杂，而且在Java中消息的通知默认是顺序执行，一个观察者卡壳，会影响
 * 整体的执行效率。在这种情况下，一般考虑采用异步的方式。
 * 多级触发时的效率更是让人担忧，大家在设计时注意考虑。
 *
 * 项目中真实的观察者模式
 *
 * 观察者和被观察者之间的消息沟通
 * 被观察者状态改变会触发观察者的一个行为，同时会传递一个消息给观察者，这是正确 的，在实际中一般的做法是：观察者中的update方法接受两个参数，一个是被观察者，一个 是DTO（Data Transfer Object，据传输对象），DTO一般是一个纯洁的JavaBean,由被观察者
 * 生成，由观察者消费。
 * 当然，如果考虑到远程传输，一般消息是以XML格式传递。
 *
 * @author MayZhou
 */
package pattern.observer;