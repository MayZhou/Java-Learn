/**
 * 定义一个用于创建对象的
 * 接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。
 * <ul>
 *     <li>  在工厂方法模式中。抽象产品类{@link pattern.factory.factorymethod.second.Product}负责定义产品的共性，实现对事物最抽象的定义</li>
 *     <li>抽象创建类{@link pattern.factory.factorymethod.second.Creator}就是抽象工厂</li>
 *     <li>抽象工厂{@link pattern.factory.factorymethod.second.Creator}就是抽象工厂</li>
 *     <li>实现工厂{@link pattern.factory.factorymethod.second.ConcreteCreator}创建{@link pattern.factory.factorymethod.second.Product}的子类</li>
 *     <li>{@link pattern.factory.factorymethod.second.Client}模拟了具体的场景</li>
 * </ul>
 * 工厂方法模式的优点：
 * <ol>
 *     <li>良好的封装性，代码结构清晰。一个对象创建是有条件约束的，如一个调用者需
 * 要一个具体的产品对象，只要知道这个产品的类名（或约束字符串）就可以了，不用知道创
 * 建对象的艰辛过程，降低模块间的耦合。</li>
 *     <li>的扩展性非常优秀。在增加产品类的情况下，只要适当地修改具体 的工厂类或扩展一个工厂类，就可以完成“拥抱变化”。例如在我们的例子中，需要增加一个 棕色人种，则只需要增加一个BrownHuman类，工厂类不用任何修改就可完成系统扩展。</li>
 *     <li>屏蔽产品类。这一特点非常重要，产品类的实现如何变化，调用者都不需要关
 * 心，它只需要关心产品的接口，只要接口保持不变，系统中的上层模块就不要发生变化。因
 * 为产品类的实例化工作是由工厂类负责的，一个产品对象具体由哪一个产品生成是由工厂类 决定的。</li>
 *     <li>在数据库开发中，大家应该能够深刻体会到工厂方法模式的好处：如果使用JDBC 连接数据库，数据库从MySQL切换到Oracle，需要改动的地方就是切换一下驱动名称（前提 条件是SQL语句是标准语句），其他的都不需要修改，这是工厂方法模式灵活性的一个直接
 * 案例。</li>
 *     <li>工厂方法模式是典型的解耦框架。高层模块值需要知道产品的抽象类，其他的实
 * 现类都不用关心，符合迪米特法则，我不需要的就不要去交流；也符合依赖倒置原则，只依
 * 赖产品类的抽象；当然也符合里氏替换原则，使用产品子类替换产品父类，没问题！</li>
 * </ol>
 * 应用场景
 * <ol>
 *     <li>，需要灵活的、可扩展的框架时，可以考虑采用工厂方法模式</li>
 *     <li>一个连接邮件服务器的框架，有三种网络协议可供选择： POP3、IMAP、HTTP，我们就可以把这三种连接方法作为产品类，定义一个接口如 IConnectMail，然后定义对邮件的操作方法，用不同的方法实现三个具体的产品类（也就是
 * 连接方式）再定义一个工厂方法，按照不同的传入条件，选择不同的连接方式。如此设计， 可以做到完美的扩展，如某些邮件服务器提供了WebService接口，很好，我们只要增加一个
 * 产品类就可以了。</li>
 *     <li>工厂方法模式可以用在异构项目中，例如通过WebService与一个非Java的项目交 互</li>
 *     <li>可以使用在测试驱动开发的框架下。例如，测试一个类A，就需要把与类A有关 联关系的类B也同时产生出来，我们可以使用工厂方法模式把类B虚拟出来，避免类A与类B 的耦合。</li>
 *     <li></li>
 *     <li></li>
 * </ol>
 * @author MayZhou
 */
package pattern.factory.factorymethod;